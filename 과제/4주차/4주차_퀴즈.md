[TOC]

<hr>





# 퀴즈

### 1. 리눅스 환경에서 프로세스에 대한 설명으로 옳지 않은 것은?

```
ps 명령어를 사용하면 실행중인 프로세스 정보를 확인할 수 있다.
실행 중인 프로세스들은 고유한 프로세스 ID(PID)로 구분할 수 있다.
실행 중인 임의의 프로세스에 대해, 해당 프로세스의 부모 프로세스 ID는 알 수 없다.
Init 프로세스는 PID 1을 가지며 운영체제에서 생성된다.
```

> 3

<br>

### 2. C로 프로그램을 작성하는 중 현재 프로세스 ID(PID)를 얻고자 한다. 방법으로 옳은 것은?

```
getpid() 함수를 사용한다.
fork() 함수를 사용한다.
"/proc/sys/kernel/pid_max" 파일의 내용을 사용한다.
ps 명령어를 사용해 init 프로세스의 PID를 사용한다.
```

> 1

<br>

### 3. 프로세스를 생성하기 위해서 준비해야 하는 공간(Segment)이 아닌것은?

```
QUEUE
STACK
HEAP
TEXT
```

> 1



<br>

### 4. 프로세스 생성과 관련된 설명으로 옳은 것은?

```
fork() 함수를 사용해 새로운 프로세스를 생성한 경우, 프로그램은 자신이 부모 프로세스인지 자식 프로세스인지 구분할 수 없다.

fork() 함수를 사용해 새로운 프로세스를 생성할 수 있으며 생성된 프로세스는 함수를 호출한 프로세스의 자식 프로세스가 된다.

자식 프로세스는 부모 프로세스와 BSS Segment, DATA Segment 등을 비롯한 모든 메모리 공간을 공유하며 모든 변경사항을 공유한다.

생성된 자식 프로세스는 프로그램의 가장 처음 부터 다시 시작한다.
```

> 2
>
> 1 -> ㄴㄴ 알 수 있음
>
> 3 -> ㄴㄴ 공간을 복사하는거여서 별도 공간임
>
> 4 -> ㄴㄴ fork 시스템콜 이후 코드부터 실행



<br>

### 5. exec 계열 함수 (execl, execlp, ...)에 대한 설명으로 옳지 않은 것은?

```
exec 함수는 현재 프로세스 이미지를 새로운 이미지로 교체한다.
execve() 함수를 사용하면 환경 변수(Environment variable)을 임의로 설정할 수 있다.
exec를 호출하는 코드에서 exec 뒤의 코드는 exec가 실패했을 때만 실행된다.
exec 계열 함수는 현재 프로세스 이미지를 별도 메모리 공간에 복사해 둔다.
```

>4
>
>노노 현재 프로세스 공간에 새 프로세스 이미지를 **덮어** 씌움!!



<br>

### 6. 프로세스 생성과 종료에 관련하여 옳은 것은?

```
exec 함수를 사용해 생성된 프로세스는 wait()을 사용해 그 종료를 기다려야 한다.

fork 함수를 사용해 자식 프로세스를 생성하면 부모 프로세스는 exit 함수를 사용해 그 종료를 자식 프로세스에게 알려야 한다.

wait 함수를 사용하면 자식 프로세스의 종료를 기다릴 수 있다.

자식 프로세스가 부모 프로세스보다 먼저 종료되는 경우, 부모 프로세스를 Zombie Process라 한다.
```

> 3
>
> 자식 프로세스가 종료할때까지 부모가 기다림 

<br>

### 7. 자식 프로세스 생성시 발생하는 메모리 복사 비용을 줄이기 위한 기법으로 옳은 것은?

```
Mutual Exclusion
Virtual File System
Copy-on-write
Readahead
```

> 3
>
> 부모 또는 자식 프로세스가 해당 페이지를 읽기가 아닌, 쓰기 처음 요청 시! 이 때 페이지를 복사하고, 분리함



<br>

### 8. 리눅스 환경에서 부모 자식 관계의 두 프로세스가 있다. 각 프로세스의 메모리 공간에 대한 설명으로 옳은 것은?

```
각 프로세스가 접근하는 메모리 주소는 물리 메모리 공간에 대한 주소이며 두 프로세스가 갖는 메모리 공간은 물리적으로 분리되어 있다.

Copy-on-write 기법이 적용된 경우, 부모 프로세스와 자식 프로세스는 일부 메모리 공간을 공유할 수 있다.

두 프로세스의 메모리 공간중 커널 영역은 반드시 분리되어야 하며 물리적으로 다른 공간을 사용해야 한다.

리눅스 프로세서 메모리 공간은 User Space, Kernel Space, Data Space로 이루어져 있다.
```

> 2
>
> Copy-on-write 기법이 적용된 경우 최초 write 전까지는 부모 프로세스의 물리메모리 커널 페이지 공유해서 읽는다고..



<br>

### 9. 프로세스 종료와 관련하여 옳지 않은 설명은?

```
exit() 함수를 사용하면 현재 프로세스를 즉시 종료할 수 있다. ㅇㅇ
부모 프로세스는 자식 프로세스의 종료 상태 코드를 확인할 수 있다. ㅇㅇ
atexit() 함수를 사용하여 프로세스 종료시 실행할 함수를 등록할 수 있다. ㅇㅇ
main 함수에서 return하는 것과 달리 exit()을 호출하였을 경우, 프로세스가 오픈한 파일은 닫지 않는다.
```

> 4



<br>

### 10. 프로세스의 종료 상태 회수에 관한 설명으로 옳은 것은?

```
프로세스 종료 상태는 정상 종료시에만 부모 프로세스에 의해 회수될 수 있으며, 이때 사용되는 함수는 exit 이다.

종료 상태 코드는 WIFEXITED() 를 사용해 정상 종료인지 확인해 볼 수 있다.

자식 프로세스가 종료되면 종료 상태를 회수 할때 까지 현 프로세스 상태를 모두 가지고 대기한다.

자식 프로세스의 정상 종료는 main 함수에서의 return 으로만 가능하다.
```

> 2



<br>

### 11. 프로세스 스케쥴링과 관련한 설명으로 옳지 않은 것은?

```
nice() 함수를 사용하여 프로세스의 우선 순위를 설정할 수 있다. ㅇㅇ
프로세스에 설정된 우선 순위는 프로세스 스케쥴러에 따라 효과가 없을 수도 있다. ㅇㅇ
getpriority() 함수를 사용하면 프로세스, 프로세스 그룹, 유저에 따른 우선 순위를 읽어올 수 있다. ㅇㅇ
setpriority() 함수를 사용해 설정한 모든 우선 순위는 모든 경우에서 효과를 발휘한다.
```

> 4



<br>

### 12. 프로세스간 커뮤니케이션(Inter-process Communication, IPC)에 관한 설명으로 옳지 않은 것은?

```
파이프(Pipe)는 단방향으로만 데이터 전송이 가능하다. ㅇㅇ
Pipe는 부모 프로세스에서 자식 프로세스로 데이터를 전송할 수 있다. ㅇㅇ
메시지 큐(Message Queue)는 LIFO(Last-in First-out) 방식으로 데이터 전송한다.
Message Queue는 부모-자식 프로세스 뿐만 아니라 임의의 두 프로세스간 데이터 전송에 사용될 수 있다. ㅇㅇ
```

> 3 
>
> 삐뽀삐뽀 FIFOFIFO



<br>

### 13. IPC 기법 중 공유 메모리와 관련된 함수가 아닌 것은?

```
shmget(...) 생성
shmat(...) 연결
atexit(...)
shmdt(...) 해체
```

> 3
>
> -> 프로세스 종료시 실행될 함수를 등록하기 위해 사용

<br>

### 14. 시그널에 관한 설명 중 옳지 않은 것은?

```
SIGKILL 시그널은 프로세스를 종료시키는 시그널이며 무시할 수 없다. ㅇㅇ
SIGTERM 시그널은 프로세스를 종료시키는 시그널이다. 
프로세스가 시그널을 받았을 때 수행할 동작은 커널에 의해 미리 정해지며 임의로 변경할 수 없다.
시그널의 종류와 번호는 kill -l 을 사용해 확인할 수 있다.
```

> 3



<br>

### 15. 쉘 스크립트에 대한 설명으로 옳지 않은 것은?

```
쉘 스크립트는 반드시 컴파일 과정을 거쳐야한다.
쉘 스크립트의 가장 첫줄 "#!/bin/bash"는 해당 스크립트가 bash 쉘을 통해 해석되야 함을 나타낸다. ㅇㅇ
echo를 사용하면 화면에 문자를 출력할 수 있다. ㅇㅇ
실행하기 위해서는 실행 권한을 부여해야한다. ㅇㅇ
```

> 1



<br>

### 16. 다음 쉘 스크립트 구문 중 옳은 문법은?

```
#include<stdio.h>
name='Victor'
int x = 3.55;
key, _ := (1, 4);
```

> 2



<br>

### 17. Pthread에 관한 설명으로 옳지 않은 것은?

```
POSIX Thread의 별칭이며 thread 생성 및 관리를 위한 핵심 라이브러리이다. ㅇㅇ
glibc에 포함되어 있으며 별도 컴파일 옵션이 필요하지 않다.
Thread 동기화를 위한 API를 제공한다.
pthread_mutex_lock, pthread_mutex_unlock 함수들을 사용해 Mutex를 사용할 수 있다.
```

> 2
>
> 명시적으로 옵션 넣어야 한댔는뎅.. `gcc -pthread`



<br>

### 18. 다음 Pthread에 포함된 함수들에 대한 설명으로 옳지 않은 것은?

```
pthread_create(...) 함수는 thread를 생성하는 함수이며 thread가 실행할 함수를 지정해 줄 수 있다.
pthread_exit(...) 함수는 현재 실행중인 쓰레드를 종료시킨다.
pthread_sem_init(...) 함수는 세마포어 자료구조를 초기화 한다.
pthread_join(...) 함수는 스레드 종료를 대기하고 종료 상태를 회수한다.
```

> 3



<br>

### 19. 여러 쓰레드가 수행하고 있는 코드 중 일부이다. 다음 코드 라인 중 상호 배제가 보장되는 라인은?

```
x = 0;
pthread_mutex_lock(&mut);
x = go_beyond(x);
pthread_mutex_unlock(&mut);
```

> 2



<br>

### 20. 다음은 pthread_create 함수의 인자들에 대한 설명이다 옳지 않은 것은?

```
pthread_t *thread : 스레드의 종료 상태 값
const pthread_attr_t *attr : 스레드 특성 설정
void *( *start_routine )(void *) : 스레드가 실행할 함수
void *arg : 스레드가 실행할 함수의 인자
```

> 1
>
> -> 생성된 스레드 식별자



<br>

### 21. Pthread의 API 사용과 관련한 설명 중 옳은 것은?

```
Pthread API를 사용해 생성한 Thread들은 공유 변수에 대해 기본적으로 동기화를 제공해 별도 기법이 필요 없다.

Pthread API를 사용해 Process를 생성할 수 있으며 생성한 Process의 Thread 또한 Control 가능하다.

Pthread API는 Semaphore를 포함하지 않는다.

Pthread는 glibc에 이미 포함되어 잇다. 
```

> 2



<br>

### 22. Pthread 사용 중 Thread가 종료되었을 때 즉시 관련 리소스를 해제하도록 설정 하기 위해 사용할 수 있는 함수로 적절한 것은?

```
getpriority(...)
pthread_mutex_lock(...)
sem_init(...)
pthread_detach(...)
```

> 4



<br>

### 23. 다음 메모리 맵핑 함수 mmap에 대한 설명 중 옳지 않은 것은?

```
mmap 함수는 OS가 개발될 때 정해진 지정된 크기로만 메모리를 맵핑할 수 있다.
mmap은 파일을 메모리 공간에 맵핑할 수 있다.
mmap을 사용하기 위해서는 sys/mman.h 파일을 include 해야한다.
다른 프로세스와 공유할 수 있는 메모리 맵핑을 생성할 수 있다.
```

>



<br>

### 24. mmap 함수의 인자 중 prot은 맵핑하는 메모리 영역의 보호 모드를 설정할 수 있다. 다음 중 설정할 수 있는 보호 모드의 설명으로 옳지 않은 것은?

```
PROT_EXEC : 실행할 수 없음.
PROT_READ : 읽을 수 있음.
PROT_WRITE : 쓸 수 있음.
PROT_NONE : 접근 불가
```

> 

<br>

### 25. mmap을 이용한 파일 쓰기 단계 중 옳지 않은 것은?

```
mmap함수를 이용해 가상 메모리 주소에 파일을 맵핑함.
맵핑된 메모리 주소에 대해 데이터를 기록.
커널은 데이터를 저장 매체(HDD/SSD)에 기록.
맵핑 해제와 파일 close.
```

> 

<br>

### 26. mmap을 통해 맵핑한 메모리 공간을 해제하기 위한 함수로 적절한 것은?

```
read()
close()
munmap()
destroy()
```

> 



<br>

### 27. mmap을 사용해 맵핑한 메모리 주소 영역에 대해 동기화를 하기 위한 함수로 적절한 것은?

```
msync()
mlock()
munlock()
mfence()
```

> 



<br>

### 28. 맵핑된 메모리 영역을 동기화 하는 방법 중 택할 수 있는 방식이 아닌 것은?

```
MS_ASYNC: 비동기 방식으로 결과에 관계 없이 프로그램 속행
MS_SYNC: 동기 방식으로 결과를 확인 후 프로그램 속행
MS_ALERT: 동기화 후 시그널을 통해 알림.
MS_INVLIDATE: 현제 메모리 맵을 무효화함.
```

> 



<br>

### 29. inode로 부터 얻을 수 있는 메타데이터와 가장 관련이 없는 것은?

```
파일을 구성하는 데이터의 저장 매체상 위치
파일의 소유자
파일의 크기
파일이 저장되어 있는 디렉토리의 이름
```





<br>

### 30. inode의 메타데이터를 얻기위한 함수로 적절하지 않은 것은?

```
fstat(...)
stat(...)
lstat(...)
openat(...)
```


[TOC]

# 서술형

### 1. 다음과 같이 스케쥴링 정책이 적용되어 있는 General Purpose 운영체제가 있습니다. 다음 정책이 실제 어떻게 동작할지를 가능한 상세히 기술해주세요.

```
- Round Robin 스케쥴링 정책
	- 100ms 마다 다음 프로세스로 교체
	- Ready Queue, Running Queue, Block Queue 존재
	- 각 Queue 는 FIFO 정책으로 동작함
- 인터럽트로 선점 가능 (선점형 스케쥴링 기능 지원)
- 타이머 인터럽트를 지원하며, 타이머 칩에서는 1ms 마다 인터럽트를 발생시킴
- CPU만 실행하는 A, B, C 프로세스가 Ready Queue 에 기술한 순서대로 들어간 상태임
	- 각 프로세스가 총 실행해야 하는 시간은 다음과 같음
	- A 는 200ms, B 는 500ms, C 는 300ms

➡ 위에서 기술한 사항 외에 추가 가정이 꼭 필요한 경우에는 각자 가정한 상황을 기술하고, 동작 방식을 기술하세요.
```

```
* 타이머 인터럽트는 1ms, 라운드 로빈 스케쥴링은 100ms 마다 교체, 각 프로세스의 I/O 등 블록에 관한 상황이 없기 때문에 연달아 실행이 가능하다는 가정

1. Ready Queue에 먼저 들어온 A 부터 Running Queue에 들어간다.

2. 100ms의 실행이 끝나면 타이머 인터럽트를 인지한 라운드 로빈 스케쥴링이 일정 시간내에 프로세스가 끝나지 않아 다음 프로세스로 교체한다.

3. A 프로세스를 Ready Queue의 마지막에 넣게 되고, Ready Queue의 B 프로세스를 Running Queue에 넣고 프로세스가 실행. 

3. 위처럼 타이머 인터럽트를 인지한 스케쥴링이 Ready Queue -> Running Queue -> Ready Queue 순으로 프로세스를 교체하며 프로세스 실행한다.

결과: A -> B -> C -> A(exit) -> B -> C -> B -> C(exit) -> B -> B(exit)
```



### 2. 다음과 같이 메모리 정책이 적용되어 있는 General Purpose 운영체제가 있습니다. 다음 정책이 실제 내부적으로 어떻게 동작할지를 가능한 상세히 기술해주세요.

```
- 페이징 시스템을 기반으로 한 가상 메모리 시스템 지원
- 요구 페이징을 지원하며, 하드웨어에서는 MMU와 TLB 칩을 지원함

➡ 위에서 기술한 상황에서 특정 프로세스가 실행 후, CPU 상에서 가상 주소로 메모리에서 데이터를 가져와야 할때, 이 동작이 어떻게 진행될지를 가능한 상세히 기술해주세요
```

```
1. 프로세스의 코드를 실행하기 위해 CPU 가 가상 주소를 MMU 에 요청한다.
2. MMU가 TLB에 물리 주소 캐싱이 되어 있는지 확인한다.

[TLB 캐싱이 되어있는 경우]
3. 캐싱이 되어있다면 메모리의 물리주소의 해당 페이지 영역에 접근한다.
4. 데이터를 반환한다.

[TLB 캐싱이 되어있지 않는 경우]
3. CR3 레지스터의 base adress를 확인해 물리 메모리의 해당 페이지 테이블로 이동한다.
4. 해당 페이지 테이블의 valid, invalid 비트를 확인해 실제 데이터가 메모리에 적재되어있는지 확인한다.
	4-1. valid 비트일 경우 물리 메모리의 해당 페이지 영역 데이터 반환한다.
    4-2. invalid 비트일 경우 OS에 page fault 인터럽트 발생한다.
5. 인터럽트를 받은 OS는 저장 매체에서 해당 데이터를 찾고, 물리 메모리에 적재 및 페이지 테이블 업데이트한다.
6. cpu가 가상 주소를 다시 요청하여 실행한다.
```



### 3. 다음과 같은 운영체제가 설치된 컴퓨터가 있을 때, 사용자가 컴퓨터를 켰을 때부터, 운영체제가 프로세스를 실행하고 쉘을 실행할 때까지 어떻게 동작할지를 가능한 상세히 기술해주세요.

```
- 컴퓨터는 BIOS를 지원하고, 부팅을 지원하는 bootstrap loader 가 별도로 설치되어 있음
- 운영체제 커널은 실행후, 최초 프로세스(init)를 운영체제 코드상에서 바로 실행시키며, 
- 이후에는 fork() 기능을 지원하며, 쉘 프로그램을 실행시킴
- 쉘 프로그램을 통해 사용자는 각 프로그램을 실행시킬 수 있음

➡ 위에서 기술한 사항 외에 추가 가정이 꼭 필요한 경우에는 각자 가정한 상황을 기술하고, 동작 방식을 기술하세요.
```

```
1. CPU는 ROM의 FFFF0H 주소의 BIOS 로드 코드를 메모리에 적재하여 BIOS 프로그램을 물리 메모리에 올리고 실행한다.
2. BIOS 프로그램은 컴퓨터를 초기화 하고, 저장 매체의 특정 섹터인 MBR(Master Boot Record)에 부트 로더 코드와 파티션 테이블 정보를 메모리에 올리고 실행한다.
3. 부트 로더는 OS가 설치된 파티션의 부트 섹터(저장매체)로 접근해 부트 코드를 메모리에 올리고 실행한다.
4. 부트 코드엔 커널 이미지가 포함 되어 있어 해당 파티션 안의 커널 이미(운영체제 실행파일)을 로드한다. 
5. 운영체제 실행 완료시 최초 프로세스가 실행되고, fork() 로 쉘 프로그램을 실행한다.
6. 현재 fork 된 프로세스의 pc는 쉘 프로그램 실행 직후를 가르키고 있고, 사용자에게 쉘 프로그램을 지원한다.
```



### 4. 다음과 같은 General Purpose 운영체제에서, 사용자가 커멘드창을 오픈한 후, ls (dir) 커멘드를 키보드로 작성할 때, 실제 내부적으로 어떻게 동작하는지 가능한 상세히 기술해주세요

```
- 사용자가 커멘드창을 오픈하면, 자동으로 쉘프로그램이 실행됨
- ls 명령은 윈도우의 dir 과 마찬가지로 해당 디렉토리의 정보를 보여주는 프로그램임
- 해당 쉘에서는 키보드를 입력하면, 해당 키보드 문자가 화면에 표시하며, 엔터를 누르면 그동안 입력받은 문자열을 명령으로 인식하고, 해당 명령을 실행함
- 스케쥴링 방식은 선점형을 지원하며, 기본적으로 멀티 태스킹을 지원함
- 인터럽트를 지원하며, 키보드 인터럽트와 타이머 인터럽트를 지원함
- 타이머 인터럽트는 1ms 마다 발생함
- 사용자는 키보드로 l 과 s 그리고 엔터키를 누를 때 각기 인터럽트가 발생함
- ls 프로그램이 실행되면, 내부적으로 필요시 시스템콜을 호출할 수 있음

➡ 위에서 기술한 사항 외에 추가 가정이 꼭 필요한 경우에는 각자 가정한 상황을 기술하고, 동작 방식을 기술하세요.
```

```
1. 'l' 클릭 시 외부 인터럽트가 발생하여 OS에 전달하고, 파일 시스템을 통해 캐릭터 디바이스의 입력 값을 확인한 OS는 모니터 디바이스에 해당 단어 출력한다.
2. 's' 역시 위와 마찬가지로 동작.
3. 엔터 키 입력 시 터미널에 입력받은 문자열을 명령어로 인식하여 /bin/ls 프로그램을 실행한다.
4. ls 실행 시 현재 위치한 디렉토리 엔트리 정보를 확인하고, 모니터 디바이스에 해당 데이터 출력한다.
```

